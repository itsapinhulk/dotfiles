# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

_IS_PLATFORM_MACOS="no"
if [[ "$(uname)" == 'Darwin' ]]; then
    _IS_PLATFORM_MACOS="yes"
fi

export XDG_CONFIG_HOME=$HOME/.config
export XDG_CACHE_HOME=$HOME/.cache
export XDG_DATA_HOME=$HOME/.local/share
export XDG_STATE_HOME=$HOME/.local/state

export FIGNORE=$FIGNORE:DS_Store

if ls --version &> /dev/null; then
    # Only create alias for supported ls variants
    alias ls="ls -F --color=auto"
fi

alias ll="ls -ltr"
alias la="ls -altr"
alias lh="ls -altrh"

if which --version &> /dev/null; then
    # only create alias for supported which variants
    alias which="alias | which --tty-only --read-alias --show-dot --show-tilde"
fi

if [[ -f ~/.bash_profile ]]; then
  alias refresh_bash_profile='source ~/.bash_profile'
elif [[ -f ~/.bashrc ]]; then
  alias refresh_bash_profile='source ~/.bashrc'
fi

umask u=rwx,g=rx,o=

export TERM=xterm-256color

export PATH=$PATH:/usr/local/bin

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=100000

# Extended regex matching
shopt -s extglob

# append to the history file, don't overwrite it
shopt -s histappend

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# Set up dotfiles directory
if command -v realpath &> /dev/null; then
    _DOTFILES_DIR=$(cd $(dirname $(realpath ${BASH_SOURCE[0]})) && cd .. && pwd)
else
    _DOTFILES_DIR=$(cd $(dirname ${BASH_SOURCE[0]}) && cd .. && pwd)
fi

if command -v dircolors &> /dev/null; then
    eval `dircolors ${_DOTFILES_DIR}/ext/dircolors-solarized/dircolors.256dark`
else
  export CLICOLOR=1
  export LSCOLORS=GxFxCxDxBxegedabagaced
fi

function source_git_helpers() {
  GIT_PS1_SHOWDIRTYSTATE=1
  GIT_PS1_SHOWUNTRACKEDFILES=1
  GIT_PS1_SHOWUPSTREAM="verbose"
  GIT_PS1_SHOWCOLORSHINT=1
  PROMPT_COMMAND='__git_ps1 "$(_ps1_pre)" "$(_ps1_post)"'
}

# Initialize only once to avoid stomping PATH
if [[ ! -v HOMEBREW_PREFIX ]]; then
  if [[ -d /home/linuxbrew/.linuxbrew/ ]]; then
    eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
  elif [[ -d /opt/homebrew/ ]]; then
    eval "$(/opt/homebrew/bin/brew shellenv)"
  fi
fi

if command -v brew &>/dev/null; then
  export BASH_COMPLETION_COMPAT_DIR="$(brew --prefix)/etc/bash_completion.d"
  if [[ -r "$(brew --prefix)/share/bash-completion/bash_completion" ]]; then
    source "$(brew --prefix)/share/bash-completion/bash_completion"
  fi
fi

if command -v _comp__split_longopt &> /dev/null; then
    _split_longopt() { _comp__split_longopt "$@"; }
fi

if command -v jj &> /dev/null; then
  source <(jj util completion bash)
fi

function source_conda_install() {
  if [[ -f "${HOME}/Software/miniconda/etc/profile.d/conda.sh" ]]; then
    source "${HOME}/Software/miniconda/etc/profile.d/conda.sh"
  else
    echo "Missing conda installation"
  fi
}
export -f source_conda_install

function activate_conda_env() {
  # Load conda if not already available
  if ! command -v conda &> /dev/null; then
    source_conda_install
  fi

  conda activate "$1"
}
export -f activate_conda_env

function source_nvm_install() {
  if command -v brew &> /dev/null; then
    export NVM_DIR="${XDG_CONFIG_HOME}/nvm"
    # This loads nvm
    [[ -s "${HOMEBREW_PREFIX}/opt/nvm/nvm.sh" ]] && source "${HOMEBREW_PREFIX}/opt/nvm/nvm.sh"
    # This loads nvm bash_completion
    [[ -s "${HOMEBREW_PREFIX}/opt/nvm/etc/bash_completion.d/nvm" ]] && source "${HOMEBREW_PREFIX}/opt/nvm/etc/bash_completion.d/nvm"
  else
    echo "Missing nvm installation"
  fi
}
export -f source_nvm_install

# Set default editor
EDITOR=nvim

# Set colorful prompt, run `colorgrid` see color values.
_USERNAME_COLOR='\[\033[01;38;05;196m\]'   # red
_PROMPT_COLOR='\[\033[01;38;05;046m\]'     # green
_VCS_COLOR='\[\033[01;38;05;208m\]'        # yellow / orange
_CONDA_COLOR='\[\033[01;38;05;005m\]'      # magenta
_TIME_COLOR='\[\033[01;38;05;105m\]'       # purple
_DIRECTORY_COLOR='\[\033[01;38;05;033m\]'  # blue
_RESET_COLOR='\[\033[00m\]'

_PS1_USER_HOST="${_USERNAME_COLOR}[\u@\h]"
_PS1_WORKDIR="${_DIRECTORY_COLOR}\w"

# Needs to be a function since the value is dynamic
function _ps1_time() {
  echo "${_TIME_COLOR}($(date '+%b-%d %H:%M'))"
}

# Needs to be a function since a lot of values are dynamic
# The split between pre and post is for the usage with git
function _ps1_pre() {
  # Unfortuantely conda prompt includes a space at the end, we need to
  # follow its convention in including its space
  _PS1_WITH_CONDA="${_CONDA_COLOR}${CONDA_PROMPT_MODIFIER}"
  echo "$(_ps1_time) ${_PS1_USER_HOST} ${_PS1_WORKDIR} ${_PS1_WITH_CONDA} ${_VCS_COLOR}"
}

# Grapes by default
PS1_OS_ICON=$'\xf0\x9f\x8d\x87'
if [[ ${_IS_PLATFORM_MACOS} == "yes" ]]; then
  # Apple for MacOS
  PS1_OS_ICON=$'\xf0\x9f\x8d\x8e'
fi

function _ps1_os_icon() {
  echo "${PS1_OS_ICON}"
}

function _ps1_post() {
  echo "\n$(_ps1_os_icon) ${_PROMPT_COLOR}\\\$ ${_RESET_COLOR}"
}

function _regular_ps1() {
  history -a  # Append to history right away
  PS1="$(_ps1_pre) $(_ps1_post)"
}

PROMPT_COMMAND='_regular_ps1'

# Needs to be after PROMPT_COMMAND is set up.
if command -v direnv &> /dev/null; then
  eval "$(direnv hook bash)"
fi

# Use current input when searching with arrow keys
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'

# Useful bash functions

_BASHRC_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
function upgrade-all-packages() {
  if command -v apt > /dev/null 2>&1; then
    sudo apt update && sudo apt --yes upgrade && sudo apt --yes autoremove
  fi

  ${_BASHRC_DIR}/../scripts/sync_brew.sh
}

if [[ -d ${_BASHRC_DIR}/../ext/itsapinhulk/shellutils/bash ]]; then
  export PATH=$(realpath ${_BASHRC_DIR}/../ext/itsapinhulk/shellutils/bash):$PATH
fi

# Single command to start all tmux sessions
function tmux_start_server() {
    for _file in $(ls ${XDG_CONFIG_HOME}/tmuxp/); do
        local _session_name="${_file%.*}"
        # Load the session in the background
        tmuxp load "${_session_name}" -d
    done
}

# Simpler alias to load a tmux session
alias tmux_attach="tmux attach-session -t"
alias tmux_kill_server="tmux kill-server"
